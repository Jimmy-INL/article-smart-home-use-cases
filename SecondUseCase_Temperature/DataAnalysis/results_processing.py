""""
Input: 
1- mode of operation. Options: 'r' or 'c'. 

The first means we want to analyze a file generated by the "realtime" operation mode,
 i. e., generated by the RealTimeStream/temperature_realtime_gen.py script.
In this case, the second input is this file's name.

The second means we want to analyze a file generated by the "constanttime"
(or "fixedtime") operation mode, i. e., generated by the DataAnalysis/constant_time_gen.py
In this case, the second input is a stream name among smallroom, smallroomwindow and bigroom.
The program finds the file by the stream name. 
Thus, the file must be located in ConstantTime folder.

Output: The input file with two new columns. 
It saves in ConstantTimeUpdated or RealTimeUpdated depending on the operation mode.

"""

import pandas as pd
import sys
from datetime import datetime
from ksql import KSQLAPI
import json
import os

TEMPERATURE_COL = 0
MEASURED_TIME_COL = 1

target_time = datetime.strptime("18:00", "%H:%M")
client = KSQLAPI('http://localhost:8088')
stream_name = ""
target_temperature = 20

def get_file_name():
    if len(sys.argv) < 3:
        print("filename missinig")
        return None
    return sys.argv[2]

def get_stream_name():
    if len(sys.argv) < 3:
        print("stream name missinig")
        return None
    return sys.argv[2]

def get_mode_operation():
    if len(sys.argv) < 2:
        print("mode operation missinig")
        return None
    return sys.argv[1]
    
def get_query_id(event):
    query_desc = event
    query_desc = query_desc.strip()
    query_desc = query_desc[1:-1]
    query_desc_json = json.loads(query_desc)
    return query_desc_json["header"]["queryId"]

def get_columns_from_message(item):
    print(item)
    item = item.strip()
    item = item[0:-1]
    json_msg = json.loads(item)
    return json_msg["row"]["columns"]
    
def get_max_temp():
    print("getting max temp")
    global stream_name
    ksql_string = f"select max(temperature) from {stream_name + 'dummy'} group by dummy emit changes limit 1;"
    streamProperties = {"ksql.streams.auto.offset.reset": "earliest"}
    query = client.query(ksql_string, stream_properties=streamProperties)
    
    queryid = get_query_id(next(query))
    print(queryid)
    for result in query:
        columns = get_columns_from_message(result)
        return columns[0]
    
    #client.close_query(queryId)
    return None
    
def get_max_time():
    print("getting max time")
    global stream_name
    ksql_string = f"select max(measured_time) from {stream_name + 'dummy'} group by dummy emit changes limit 1;"
    streamProperties = {"ksql.streams.auto.offset.reset": "earliest"}
    query = client.query(ksql_string, stream_properties=streamProperties)
    
    queryid = get_query_id(next(query))
    print(queryid)
    for result in query:
        columns = get_columns_from_message(result)
        return columns[0]
    
    #client.close_query(queryId)
    return None
    

def get_closest_simulated_temperature(temperature):
    
    global stream_name
    if temperature < 0 and temperature > -0.1:
        temperature = -0.1
    elif temperature > 0 and temperature < 0.1:
        temperature = 0.1
    ksql_string = f"select * from {stream_name} where temperature >= {temperature} emit changes limit 1;"
    streamProperties = {"ksql.streams.auto.offset.reset": "earliest"}
    query = client.query(ksql_string, stream_properties=streamProperties)
    
    queryid = get_query_id(next(query))
    print(queryid)
    for result in query:
        columns = get_columns_from_message(result)
        time = columns[MEASURED_TIME_COL]
        return time
    
    #client.close_query(queryId)
    return None

def get_closest_simulated_time(measured_time):
    
    global stream_name
    ksql_string = f"select * from {stream_name} where measured_time >= {measured_time} emit changes limit 1;"
    print(ksql_string)
    streamProperties = {"ksql.streams.auto.offset.reset": "earliest"}
    query = client.query(ksql_string, stream_properties=streamProperties)
    
    _ = get_query_id(next(query))

    for result in query:
        columns = get_columns_from_message(result)
        temperature = columns[TEMPERATURE_COL]
        return temperature
    
    #client.close_query(queryId)
    return None

def parse_file_df(df, result_file_name):
    df.head()                 

    simulated_temp_on_target_col = pd.Series([])
    time_heater_on = pd.Series([])
    max_time = get_max_time()
    print("max time", max_time)
    max_temp = get_max_temp()
    print("max_temp", max_temp)

    for index, row in df.iterrows(): 
        
        if row["actiontime"] == "None" or row["temperature"] >= target_temperature:
            simulated_temp_on_target_col[index] = 'None'
            time_heater_on[index] = 'None'
            continue
        
        closest_temp_time = get_closest_simulated_temperature(row['temperature'])
        
        time_action_taken = datetime.strptime(row['actiontime'], "%H:%M")
        period_heater_on_until_target = (target_time - time_action_taken).total_seconds()
        
        simulated_target_time = closest_temp_time + period_heater_on_until_target
        if simulated_target_time < max_time:
            simulated_temp_on_target = get_closest_simulated_time(simulated_target_time)
        else:
            simulated_temp_on_target = max_temp
        
        simulated_temp_on_target_col[index] = simulated_temp_on_target
    
        hours, rem = divmod(period_heater_on_until_target, 3600)
        minutes, seconds = divmod(rem, 60)
        time_heater_on[index] = f"{int(hours)}:{int(minutes)}"
        print("index = ", index, "temp on ", simulated_target_time, " was = ", simulated_temp_on_target)

    df.insert(3, "SimulatedTemperature", simulated_temp_on_target_col)
    df.insert(4, "TimeHeaterOn", time_heater_on)
    df.head()
    print(df)
    df.to_csv(result_file_name)
 
mode_operation = get_mode_operation()
if mode_operation == 'r':
    filename = get_file_name()
    head, tail = os.path.split(filename)
    result_filename = tail.split('.')
    stream_name = result_filename[0][:-3] + 'stream' 
    result_file_name = "RealTimeUpdated/" + result_filename[0] + "Updated.csv"
    print(result_file_name)
    df = pd.read_csv(filename,
                    header=0,
                    low_memory=False)
    print(df)
    parse_file_df(df, result_file_name)
elif mode_operation == 'c':
    for month_name in ["JAN", "FEV", "MAR", "APR"]: 
        filename = get_stream_name()
        stream_name = filename + 'stream'
        df = pd.read_csv(f"ConstantTime/{month_name}.csv",
                    header=0,
                    low_memory=False)
        result_filename = f"ConstantTimeUpdated/{filename}{month_name}.csv"
        parse_file_df(df, result_filename)
else:
    print("invalid mode of operation")




